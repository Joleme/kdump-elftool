.TH kdump-tool 1 06/02/01  "Kdump dump handling tool"

.SH NAME
kdump-tool \- Kdump dump handling tool

.SH SYNOPSIS
.B kdump-tool
[\-\-help] topelf [\--help]
[\-\-oldmem|\-i <oldmem>]
[\-\-outfile|-o <output file>]
[\-\-vmcore|-v <vmcore>]
[\-\-elfclass|-c 32|64]
[\-\-level|-l all|inuse|user|cache|kernel]
[\-\-debug|-d]

.B kdump-tool
[\-\-help] tovelf [\--help]
[\-\-infile|\-i <oldmem or pelf>]
[\-\-outfile|-o <output file>]
[\-\-vmcore|-v <vmcore>]
[\-\-intype|-I oldmem|pelf]
[\-\-physpgd|-P <pgd phys address>]
[\-\-elfclass|-c 32|64]
[\-\-level|-l all|inuse|user|cache|kernel]
[\-\-vmlinux|-m <vmlinux>]
[\-\-debug|-d]

.B kdump-tool
[\-\-help] addrandoff [\--help]
[\-\-vmcore|-v <vmcore>]
[\-\-vmlinux|-m <vmlinux>]

.B kdump-tool
[\-\-help] makedyn [\--help]
<vmlinux> [<vmlinux> [...]]

.B kdump-tool
[\-\-help] dumpmem [\--help]
[\-\-infile|\-i <oldmem or pelf>]
[\-\-outfile|-o <output file>]
[\-\-vmcore|-v <vmcore>]
[\-\-intype|-I oldmem|pelf]
[\-\-is_physical|-p]
<address> <size>

.B kdump-tool
[\-\-help] virttophys [\--help]
[\-\-infile|\-i <oldmem or pelf>]
[\-\-vmcore|-v <vmcore>]
[\-\-intype|-I oldmem|pelf]
[\-\-physpgd|-P <pgd phys address>]
[\-\-debug|-d]
<address>

.SH DESCRIPTION
The
.BR kdump-tool
program extracts kernel coredumps from the target and processes those
coredumps into something gdb can understand.
.PP
In a kdump crash kernel, there are two files that let you extract
information about the kernel that just crashed: /dev/mem and
/proc/vmcore.  /dev/mem is a raw file holding an image of the physical
memory of the system, including the previous host's memory.
/proc/vmcore is a kernel coredump plus some extra information.  (See
.BR RATONALE
for why this coredump is not sufficient.)

.BR kdump-tool
deals with two other types of files, both elf files.  Physical memory
elf files (pelf) and virtual memory elf files (velf).  A pelf file
holds a physical memory coredump, basically what comes out of
/dev/mem in elf format.  Note that
.BR kdump-tool
will get the physical memory ranges for the old kernel out of
/proc/vmcore, if available, and only store the necessary ranges.

A velf file holds a virtual memory coredump, this is in a format that
gdb can load load and use.  gdb needs the virtual kernel addresses to
work.

.BR "kdump-tool topelf -o <pelf file>"
will process /dev/mem and /proc/vmcore into a pelf file.  This is
generally preferred on a target system, pelf files are usually smaller
than velf files and they are quicker to process.  Plus a velf file may
not have all of physical memory, in case you are in a desperate
situation and need to get to userland memory.  Note that the output
will go to standard output if you don't specify -o.

.BR "kdump-tool tovelf -i <pelf file> -o <velf file>"
will process the pelf file into a velf file.

.BR "kdump-tool tovelf -I outmem -o <velf file>"
will process /dev/mem and /dev/vmcore directly into a velf file.

For
.BR gdb
to properly interpret kernels with a random base address, it has to be
told the load offset.  It has to have the original
.BR <vmlinux>
file to do this, then it can compare symbol offsets to symbol addresses
it has access to in the dump file.  Adding the
.BR "--vmlinux <vmlinux>"
option to the
.BR tovelf
subcommand will do this, or you can add it later to an existing virtual
memory coredump with the
.BR "kdump-tool addrandoff -m <vmlinux> -v <vmcore>"
command.

As an additional problem for debugging kernels with a random base address,
the
.BR vmlinux
compile for most architectures is marked as a regular executable, but
.BR gdb
requires that it be a relocatable executable to handle the load offset.
The command
.BR "kdump-tool makedyn <vmlinux>"
will convert a vmlinux to a relocatable executable command for you.

.BR kdump-tool
will also dump ranges of memory from the various input types it
supports using the
.BR dumpmem
subcommand.  The parameters all work as
before, with the addition of -p, which specifies the address as
physical.  Otherwise the address is assumed to be virtual.

.BR kdump-tool
can also convert logical addresses to physical addresses using the
.BR virttophys
subcommand.  This only works on physical memory files.

.SH OPTIONS
.TP
.I "\-\-help"
Output help.
.TP
.I "\-\-oldmem|\-i <oldmem>"
Set the location of the oldmem file.  The default -s /dev/mem.
.TP
.I "\-\-outfile|-o <output file>"
Set the output file, output will go to stdout if this is not supplied.
.TP
.I "\-\-vmcore|-v <vmcore>"
Set the location of the vmcore file, /proc/vmcore by default.
.TP
.I "\-\-vmlinux|-m <vmlinux>"
The vmlinux file for the core dump being processed.  Require to add the
load offset for a randomized base kernel.
.TP
.I "\-\-infile|\-i <oldmem or pelf>"
Set the location of the input file for converting to velf.  This can
either be a raw memory file (/dev/mem by default) if
.BR \-I outmem
is specified.  If
.BR \-I outmem
is not given, then this parameter is required.
.TP
.I "\-\-intype|-I outmem|pelf"
Set the input file time for conversion to velf.
.TP
.I "\-\-physpgd|-P <pgd phys address>"
Set the physical address of the pgd pointer.  This is read from the
input file, but if it is missing or wrong it can be overridden.  This
can also be used to create a coredump of a process if you have the
process' physical page directory address.  That can be obtained with
gdb.  It will only dump the process memory that is present, so if
memory is not yet paged in or has been paged out, it will not be
present.
.TP
.I "\-\-elfclass|-c 32|64"
All physical memory coredump are 64-bit because many 32-bit
architectures can map physical addresses greater than 32-bits (like
x86 PAE).  For architectures, like MIPS, where the kernel may be 32 or
64 bits, you have to set the class to 32 bits if you have a 32-bit
kernel (or are generating a coredump for a userland process that is
32-bits).  x86_64 and i386 are distinct architectures, so you won't
have a problem with the kernel, but you might have the same issue for
userland.
.TP
.I "\-\-level|-l all|inuse|user|cache|kernel"
Select which pages of memory to put into the dump.  The default level
is kernel, which will dump pages used by the kernel.  This is the most
useful, in general, for coredump analysis since free, cache, and user
pages aren't terribly relevant to analyzing the kernel.  The cache
level will dump kernel and cache pages.  The user level will dump
kernel and user pages.  The inuse level will dump all pages that are
not free, and all obviously just dumps all pages.
.TP
.I "\-\-debug|-d"
Dump debug information.  Generally only useful if you are debugging
kdump-tool itself.

.SH RATIONALE
Why not just use /proc/vmcore, you ask?  The /proc/vmcore file
generated by the kernel does not have all the virtual memory sections
available.  Particularly, vmalloc memory and vmemmap are not
available, and all of physical memory may not be present.  Since
modules reside in vmalloc and some systems have the pages array in
vmemmap, it's almost impossible to use gdb on the standard kernel
coredump.

.SH FILES
/dev/mem, /proc/vmcore

See Documentation/kdump/kdump.txt in the Linux kernel for more details.

.SH "SEE ALSO"
kexec(8)

.SH "KNOWN PROBLEMS"
This is still fairly primitive and doesn't support all architectures.

.SH AUTHOR
.PP
Corey Minyard <minyard@acm.org>
