From 3fc9b699e7fc5fc496846e9df675567ca61d4874 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Mon, 3 Feb 2014 15:54:23 -0600
Subject: [PATCH] kdump: Add system memory ranges to VMCOREINFO

On many systems it is best to not scan arbitrary memory from zero.  So
pass in the memory ranges used by the crashing kernel so the crash
kernel can only extract the memory it needs.

Also add the physical address of the init_mm page directory.  This
lets software generate a virtual memory map pretty easily.

Finally, pass in the range of the crashdump kernel so the crash kernel
can exclude it.  There's not much point in saving that memory.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
---
 include/linux/kexec.h |  7 +++++++
 kernel/kexec.c        | 23 +++++++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/include/linux/kexec.h b/include/linux/kexec.h
index a756419..82a93e2 100644
--- a/include/linux/kexec.h
+++ b/include/linux/kexec.h
@@ -161,6 +161,13 @@ unsigned long paddr_vmcoreinfo_note(void);
 	vmcoreinfo_append_str("NUMBER(%s)=%ld\n", #name, (long)name)
 #define VMCOREINFO_CONFIG(name) \
 	vmcoreinfo_append_str("CONFIG_%s=y\n", #name)
+#define VMCOREINFO_ADDRESS(name) \
+	vmcoreinfo_append_str("ADDRESS(%s)=%llx\n", #name, \
+			      (unsigned long long )name)
+#define VMCOREINFO_MEMRANGE(name, start, size) \
+	  vmcoreinfo_append_str("MEMRANGE(%s)=%llx@%llx\n", #name, \
+				(unsigned long long) (size),	   \
+				(unsigned long long) (start))
 
 extern struct kimage *kexec_image;
 extern struct kimage *kexec_crash_image;
diff --git a/kernel/kexec.c b/kernel/kexec.c
index c8380ad..dc96732 100644
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@ -1560,8 +1560,18 @@ unsigned long __weak paddr_vmcoreinfo_note(void)
 	return __pa((unsigned long)(char *)&vmcoreinfo_note);
 }
 
+static int
+save_ram_range(unsigned long start, unsigned long size, void *dummy)
+{
+	VMCOREINFO_MEMRANGE(sysram, ((unsigned long long) start) << PAGE_SHIFT,
+			    ((unsigned long long) size) << PAGE_SHIFT);
+	return 0;
+}
+
 static int __init crash_save_vmcoreinfo_init(void)
 {
+	unsigned long phys_pgd_ptr;
+
 	VMCOREINFO_OSRELEASE(init_uts_ns.name.release);
 	VMCOREINFO_PAGESIZE(PAGE_SIZE);
 
@@ -1623,6 +1633,19 @@ static int __init crash_save_vmcoreinfo_init(void)
 	VMCOREINFO_NUMBER(PG_hwpoison);
 #endif
 	VMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);
+	phys_pgd_ptr = virt_to_phys(init_mm.pgd);
+	VMCOREINFO_ADDRESS(phys_pgd_ptr);
+	walk_system_ram_range(0, -1ULL, NULL, save_ram_range);
+	if (crashk_low_res.end != 0)
+		VMCOREINFO_MEMRANGE(crashkernel,
+				    ((unsigned long long) crashk_low_res.start),
+				    ((unsigned long long) crashk_low_res.end -
+				     crashk_low_res.start + 1));
+	if (crashk_res.end != 0)
+		VMCOREINFO_MEMRANGE(crashkernel,
+				    ((unsigned long long) crashk_res.start),
+				    ((unsigned long long) crashk_res.end -
+				     crashk_res.start + 1));
 
 	arch_crash_save_vmcoreinfo();
 	update_vmcoreinfo_note();
-- 
1.8.3.1

